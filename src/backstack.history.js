/* @TODO
 * this sub-module is supposed to connect backstack with the history api
 * it should do so transparently since mudeer already has a backstack logic
 * 
 * it can be as simple as root / view / sheet / dialog
 * basically four levels
 * 
 * any app that needs to run on platforms with a back button that needs the
 * history api (like android) should include this sub-module
 * */

;(function(){
	'use strict';
	var exiting = 0, backcount = 0, lasturiuponpop, evenlasturiuponpop;
	
	// OLD LOGIC
	
	/*
	 * clear the history stack requires boilerplate code
	 * basically whenever you call history.back, you shouldn't call it again
	 * until you receive a popstate event from the browser, it is that ugly
	 * 
	 * so this module basically handles that automatically and you can register
	 * a callback to know when the back stack is completely cleared up
	 * 
	 * 
	 * 
	 * */
	var backstack = {
//		ghosturis: ['editor'],
		chronicle: [],
		// ignore e.g appui.setchanges
		nochanges: 0,
		onpopevent: function (e) {
//			$.log.s( 'backstack.onpopevent', backstack.locked );
			if (backstack.nochanges)
				backstack.nochanges = 0;
			
			if (backstack.locked)
				backstack.popandlock();
			else
				backstack.chronicle.pop();
		},
		/*
		 * marks locked as zero, no pushstate or back should be called during
		 * this state, if you do, it just pops one more entry
		 * 
		 * pops all items in the chronicle one by one
		 * does history.back once, then listens for popstate
		 * onpopevent calls popandlock again
		 * 
		 * once chronicle is empty, locked is marked as 0 again
		 * */
		locked: 0,
		crumbs: [],
		callback: 0,
		popandlock: function () {
//			$.log.s( 'backstack.popandlock' );

			if (backstack.chronicle.length) {
				backstack.chronicle.pop();
				history.back();
			} else {
				typeof backstack.callback === 'function' && backstack.callback();
				backstack.callback = 0;
			}
		},
		/*
		 * only works if chronicle is empty
		 * basically navigates to all breadcrumbs incrementially
		 * ? navigate to /attendance/students/one/2018-may-25
		 * 
		 * it'll insert these items into the back stack
		 * /attendance
		 * /attendance/student
		 * /attendance/students/one
		 * /attendance/students/one/2018-may-25
		 * 
		 * callback is called when all items are successfully pushed into stack
		 * */
		reconstruct: function (crumbs, callback) {
//			$.log.s( 'backstack.reconstruct' );

			callback = callback || appui.setchanges;
			backstack.locked = 1;
			crumbs = crumbs || [''];
			backstack.crumbs = crumbs;
			if (crumbs.length) {
				backstack.callback = function () {
					
					if (backstack.chronicle.length === 0) {
						backstack.pushstate('/');
						crumbs.forEach(function (crumb, i) {
							var currentcrumb = crumbs.slice(0, i+1);
							backstack.pushstate('/'+currentcrumb.join('/'));
						});
						
						backstack.locked = 0;
						typeof callback === 'function' && callback( crumbs );
					} else
						history.back();
				};
				backstack.popandlock();
			} else {
				backstack.callback = function () {
					if (backstack.chronicle.length === 0) {
						backstack.locked = 0;
						typeof callback === 'function' && callback( crumbs );
					} else
						history.back();
				};
				backstack.popandlock();
			}
		},
		pushstate: function (href, force) {
			href = href || location.pathname;
//			$.log.s( 'backstack.pushstate', href );

			if (location.pathname !== href || force) {
				lasturiuponpop = href;

				history.pushState(null, null, href);
				backstack.chronicle.push(href);
			}
			
		},
		replacestate: function (href) {
			history.replaceState(null, null, href);
		},
		/*
		 * no need to call appui.get here since dom+appui listen to popstate
		 * events anyway
		 * 
		 * nochanges makes sure that the popstate event generated by this back
		 * action is ignored once by appui.setchanges :p
		 * */
		back: function (nochanges) {
//			$.log.s( 'backstack.back' );

			backstack.nochanges = 1;
			
			backstack.chronicle.pop();
			history.back();
		},
	};
	Hooks.set('dompopstate', 'backstack', function (e) {
		backstack.onpopevent(e);
	});

	var chronicle = [];

	// NEW LOGIC
	/*
	 * 
	 */
	// logic below is faulty, change it to reconstruction every time
	// otherwise it's too unreliable
	listener('popstate', function (event) {
		$.log.w( 'popstate', event );
		var crumbs = location.pathname.split('/');
		if ( name.length > 1 && name[1].length ) {
			Backstack.view(name[1], 1);
			// 
			Hooks.run( 'backstack-crumbs', crumbs.slice(2) );
		} else {
			if (Backstack.darajah)
				Backstack.back();
		}
	});
	
	// backstack-* hooks are refined and validate calls
	Hooks.set('backstack-view', function (args) {
		$.log.w( 'backstack-view', args );
		history.pushState({}, '', '/'+args)
	});
	Hooks.set('ready', function () {
		$.taxeer('backstack-history-ready', function () {
			var name = location.pathname.slice(1);
			if ( name.length ) {
				Backstack.view(name, 1);
			}
		}, 100);
	});
	
})();
